% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parent.assign.fun.R
\name{parent.assign.fun}
\alias{parent.assign.fun}
\title{parent.assign.fun}
\usage{
parent.assign.fun(
  method,
  beta.min.ss = FALSE,
  discrete.method = "geno.probs",
  threshold.indiv = NULL,
  threshold.pools = NULL,
  snp.dat.indiv,
  snp.dat.pools,
  n.in.pools,
  min.intensity = 0,
  snp.error.assumed = NULL,
  snp.error.underlying = NULL,
  snp.param.indiv = NULL,
  snp.param.pools = NULL,
  min.sd = 0,
  fams,
  fam.set.combns = NULL,
  fam.set.combns.by.pool = NULL,
  skip.checks = FALSE
)
}
\arguments{
\item{method}{is a vector of methods to be implemented (e.g. c("Quantitative", "Discrete", "Exclusion", "Least_squares"))}

\item{beta.min.ss}{is a logical variable appicable to least_squares method only (default = FALSE).
If TRUE, the sum of squares of all parental combinations are computed and the combination with the minimum value is identified.  
Refer to Hamilton 2020.}

\item{discrete.method}{is a character variable applicable to the "Discrete" or "Exclusion" methods only
(default = "geno.probs").  It must equal either:
\itemize{
 \item{"geno.probs" in which case discrete genotypes for parents and pools are derived from genotype probabilities.}  
 \item{"assigned.genos" in which case discrete genotypes for parents and pools are obtained directly from the snp.dat.indiv and snp.dat.pools inputs.}
 }}

\item{threshold.indiv}{is a numeric variable between 0 and 1 inclusive applicable to the "Discrete" or "Exclusion" methods only
when discrete.method = "geno.probs" (default = NULL).  A discrete genotype is assigned to the the most likely genotype in 
the quantitative ordered genotype probability matrix Gij if it is greater than threshold.indiv (or
threshold.indiv / 2 for the two heterozygous genotypes).  Otherwise the genotype is deemed missing (refer to the left hand side of 
page 5 of Henshall et al. 2014)}

\item{threshold.pools}{is a numeric variable between 0 and 1 inclusive applicable to the "Discrete" or "Exclusion" methods only
when discrete.method = "geno.probs" (default = NULL).  Equivalent to threshold.indiv for pooled DNA samples.}

\item{snp.dat.indiv}{is a data frame with the following headings (class in parentheses):
\itemize{
 \item{'SAMPLE_ID' is the sample identifier.  Samples must be from diploid individuals (i.e. not pools) (integer).}
 \item{'SNP_ID' is the SNP identifier (character).} 
 \item{'INTENSITY_A' is the area/intensity for allele A (numeric).}
 \item{'INTENSITY_B' is the area/intensity for allele B (numeric).} 
 \item{'A_ALLELE' is the base represented by allele A (i.e. 'A', 'C', 'G' or 'T') (character).}
 \item{'B_ALLELE' is the base represented by allele B (i.e. 'A', 'C', 'G' or 'T') (character).}
 \item{'GENOTYPE' is the SNP genotype call (e.g. 'AT', 'TT').  NA if missing (character).}
}}

\item{snp.dat.pools}{is a data frame with the following headings.  Note that all pooled DNA samples 
in this dataframe must be comprised of DNA from the same number of individuals (see n.in.pools) (class in parentheses):
 \itemize{
 \item{SAMPLE_ID is the pooled sample identifier (integer).}
 \item{SNP_ID is the SNP identifier (character).}
 \item{INTENSITY_A is the signal intensity for allele A. Not required if method does not include 'Quantitative' or 'Least_squares' and discrete.method  = "geno.probs" (numeric).}
 \item{INTENSITY_B is the signal intensity for allele B. Not required if method does not include 'Quantitative' or 'Least_squares' and discrete.method  = "geno.probs" (numeric).}
 \item{GENOTYPE is the assigned unordered genotype. Not required if discrete.method = "geno.probs" (character).}
}}

\item{n.in.pools}{is an integer variable representing the number of individual that contributed DNA to each sample in snp.dat.pools}

\item{min.intensity}{is a numeric variable (default = 0).  If the square root of the sum of INTENSITY_A squared and 
INTENSITY_B squared in snp.dat.indiv or snp.dat.pools is less than min.intensity then this record is excluded.
That is, observations that fall into an arc with a radius equal to min.intensity in the lower left of
signal intensity scatter plots are excluded.}

\item{snp.error.assumed}{Must be one of (default = NULL):
\itemize{
 \item{NULL.  Note that if snp.error.assumed is NULL then snp.error.underlying must not be NULL.}
 \item{a numeric variable between 0 and 1, in which case the 'assumed error rate' (see Henshall et al 2014) is the same across all SNP.}
 \item{a data frame with columns SNP_ID and SNP_ERROR_TILDE (see Henshall et al 2014).}
}}

\item{snp.error.underlying}{is not used if snp.error.assumed is not NULL (default = NULL). Must be either:
\itemize{
 \item{NULL.}
 \item{a numeric variable between 0 and 1 inclusive.  Used to comptute SNP_ERROR_TILDE from SNP_ERROR_HAT according
                     to the approach outlined on the left of page 5 of Henshall et al. 2014 using individual 
                     (i.e. not pooled) data only.  If snp.error.underlying = 0 then SNP_ERROR_TILDE = SNP_ERROR_HAT.}
}}

\item{snp.param.indiv}{is the output of snp.param.indiv.fun (default = NULL).  That is, it is a data frame with the following 
headings (class in parentheses):
\itemize{
 \item{'SNP_ID' is the SNP identifier (character).} 
 \item{'N_AA' is the count of homozygous A (AA) genotypes (integer).}
 \item{'MEAN_P_AA' is the mean of allelic proportion for homozygous A genotypes (numeric).}
 \item{'SD_P_AA' is the standard deviation of allelic proportion for homozygous A genotypes (numeric).} 
 \item{'N_AB' is the count of heterozygous (AB) genotypes (integer).}
 \item{'MEAN_P_AB' is the mean of allelic proportion for heterozygous (AB) genotypes (numeric).}
 \item{'SD_P_AB' is the standard deviation of allelic proportion for heterozygous (AB) genotypes (numeric).}  
 \item{'N_BB' is the count of homozygous B (BB) genotypes (integer).}
 \item{'MEAN_P_BB' is the mean of allelic proportion for homozygous B genotypes (numeric).}
 \item{'SD_P_BB' is the standard deviation of allelic proportion for homozygous B genotypes (numeric).} 
 \item{'WELCH_A' is the welsh statistic for the interval between MEAN_P_AA and MEAN_P_AB (numeric).}
 \item{'WELCH_B' is the welsh statistic for the interval between MEAN_P_AB and MEAN_P_BB (numeric).}
 \item{'A_ALLELE_FREQ' is the A allele frequency computed from genotype counts (numeric).}
 \item{'B_ALLELE_FREQ' is the B allele frequency computed from genotype counts (numeric).}
 \item{'A_ALLELE' is the base represented by allele A (i.e. 'A', 'C', 'G' or 'T') (character).}
 \item{'B_ALLELE' is the base represented by allele B (i.e. 'A', 'C', 'G' or 'T') (character).}
}}

\item{snp.param.pools}{is the output of snp.param.pools.fun.  That is, it is a data frame with the following headings (class in parentheses)
\itemize{
 \item{'SNP_ID' is the SNP identifier (character).} 
 \item{'MEAN_P_AAAA' is the mean of allelic proportion for homozygous A genotypes (numeric).}
 \item{'SD_P_AAAA' is the standard deviation of allelic proportion for homozygous A genotypes (numeric).} 
 \item{'MEAN_P_AAAB' is the mean of allelic proportion for unordered AAAB genotypes (numeric).}
 \item{'SD_P_AAAB' is the standard deviation of allelic proportion for unordered AAAB genotypes (numeric).} 
 \item{'MEAN_P_AABB' is the mean of allelic proportion for unordered AABB genotypes (numeric).}
 \item{'SD_P_AABB' is the standard deviation of allelic proportion for unordered AABB genotypes (numeric).}  
 \item{'MEAN_P_ABBB' is the mean of allelic proportion for unordered ABBB genotypes (numeric).}
 \item{'SD_P_ABBB' is the standard deviation of allelic proportion for unordered ABBB genotypes (numeric).}
 \item{'MEAN_P_BBBB' is the mean of allelic proportion for homozygous B genotypes (numeric).}
 \item{'SD_P_BBBB' is the standard deviation of allelic proportion for homozygous B genotypes (numeric).}   
 \item{'A_ALLELE' is the base represented by allele A (i.e. 'A', 'C', 'G' or 'T') (character).}
 \item{'B_ALLELE' is the base represented by allele B (i.e. 'A', 'C', 'G' or 'T') (character).}
}}

\item{min.sd}{is a numberic variable defining a lower bound to be applied to estimates of the 
standard deviation of allelic proportion for genotypes in snp.param.indiv and snp.param.pools (default = 0)}

\item{fams}{is a data frame with the following headings (class in parentheses):
\itemize{
 \item{'FAMILY_ID' is the family identifier (integer).} 
 \item{'SIRE_ID' is the sire identifier (integer).} 
 \item{'DAM_ID' is the dam identifier (integer).} 
}}

\item{fam.set.combns}{is a data frame with the following headings (class in parentheses). Note: if fam.set.combns = NULL
(see 'pooling by phenotype' example below), 
FAMILY_ID is taken from the 'fams' and duplicated n.in.pools times, FAM_SET_ID = 1 for the first duplication of 
FAMILY_IDs, 2 for the second etc and FAM_SET_COMBN_ID = 1 (default = NULL):
\itemize{
 \item{'FAM_SET_COMBN_ID' is the family set combination identifier (integer). A 'family set combination' is a combination of 'family sets'.  
 Each pooled sample must be associated with one only family set combination but a family set combination
 may be assoicated with multiple pooled samples using the fam.set.combns.by.pool input below.} 
 \item{'FAM_SET_ID' is the family set identifier (integer).  A 'family set' is a group of families of which one is known to be the true family 
 of one of the individuals in a pooled sample.  Within each 'family set combination' there must be a 'family set'
 for each individual in a pooled sample (i.e. if n.in.pools = 2 there must be two family sets in each family set combination)} 
 \item{'FAMILY_ID' is the family identifier (integer).} 
}}

\item{fam.set.combns.by.pool}{is a data frame linking pooled samples with family set combinations.
It has the following headings (class in parentheses).  Note: if fam.set.combns is NULL (see 'pooling by phenotype' example below),
fam.set.combns.by.pool is made NULL.
If fam.set.combns.by.pool = NULL, FAM_SET_COMBN_ID = 1 and SAMPLE_ID is taken from the 
'snp.dat.pools' input (default = NULL):
\itemize{
 \item{SAMPLE_ID is the pooled sample identifier (integer).}
 \item{'FAM_SET_COMBN_ID' is the family set combination identifier (integer).} 
}}

\item{skip.checks}{is a logical variable.  If FALSE parent.assign.fun data checks are not undertaken.}
}
\value{
\cr
\strong{Primary outputs}

\code{most.like.parents.quant}  
\cr \cr
Applicable when method = "Quantitative".  Identifies the most likely parental combination and delta LODs for 
individual parents.  Second most likely (alternative) parents are also presented.  Refer to Hamilton 2020.  Example fields for n.in.pools = 2:
\itemize{
 \item{SAMPLE_ID (integer).}
 \item{PARENT_COMBN_ID (integer).}
 \item{MISS_PARENT_SNP_DATA_PROP (numeric).}
 \item{MISS_POOL_SNP_DATA_PROP (numeric).}
 \item{NO_MISS_PARENT_OR_POOL_PROP (numeric).}
 \item{MIN_LOGL (numeric).}
 \item{MIN_LOGL_SNP (character).}
 \item{MAX_LOGL (numeric).}
 \item{MAX_LOGL_SNP (character).}
 \item{RANGE_5_TO_95_LOGL (numeric).}
 \item{LOD (numeric).}
 \item{FAM_SET_COMBN_ID (integer).}
 \item{PARENT_1 (integer).}
 \item{PARENT_2 (integer).}
 \item{PARENT_3 (integer).}
 \item{PARENT_4 (integer).}
 \item{FAM_COMBN_ID (integer).}
 \item{FAMILY_ID_1 (integer).}
 \item{FAMILY_ID_2 (integer).}
 \item{PARENT_1_DELTA_LOD (logical).}
 \item{PARENT_2_DELTA_LOD (logical).}
 \item{PARENT_3_DELTA_LOD (numeric).}
 \item{PARENT_4_DELTA_LOD (numeric).}
 \item{ALT_PARENT_1 (logical).}
 \item{ALT_PARENT_2 (logical).}
 \item{ALT_PARENT_3 (numeric).}
 \item{ALT_PARENT_4 (numeric).}
 \item{ALT_PARENT_COMBN_1 (logical).}
 \item{ALT_PARENT_COMBN_2 (logical).}
 \item{ALT_PARENT_COMBN_3 (integer).}
 \item{ALT_PARENT_COMBN_4 (integer).}
 \item{ALT_FAM_COMBN_1 (integer).}
 \item{ALT_FAM_COMBN_2 (integer).}
 \item{ALT_FAM_COMBN_3 (integer).}
 \item{ALT_FAM_COMBN_4 (integer).}
}
\cr

\code{most.like.parents.discrete}
\cr  \cr
Applicable when method = "Discrete".  Identifies the most likely parental 
combination and delta LODs for individual parents.  Second most likely (alternative) parents are also presented.  
Refer to Hamilton 2020.  Example fields for n.in.pools = 2:
\itemize{
 \item{SAMPLE_ID (integer).}
 \item{PARENT_COMBN_ID (integer).}
 \item{MISS_PARENT_SNP_DATA_PROP (numeric).}
 \item{MISS_POOL_SNP_DATA_PROP (numeric).}
 \item{NO_MISS_PARENT_OR_POOL_PROP (numeric).}
 \item{MIN_LOGL (numeric).}
 \item{MIN_LOGL_SNP (character).}
 \item{MAX_LOGL (numeric).}
 \item{MAX_LOGL_SNP (character).}
 \item{RANGE_5_TO_95_LOGL (numeric).}
 \item{LOD (numeric).}
 \item{FAM_SET_COMBN_ID (integer).}
 \item{PARENT_1 (integer).}
 \item{PARENT_2 (integer).}
 \item{PARENT_3 (integer).}
 \item{PARENT_4 (integer).}
 \item{FAM_COMBN_ID (integer).}
 \item{FAMILY_ID_1 (integer).}
 \item{FAMILY_ID_2 (integer).}
 \item{PARENT_1_DELTA_LOD (logical).}
 \item{PARENT_2_DELTA_LOD (logical).}
 \item{PARENT_3_DELTA_LOD (numeric).}
 \item{PARENT_4_DELTA_LOD (numeric).}
 \item{ALT_PARENT_1 (logical).}
 \item{ALT_PARENT_2 (logical).}
 \item{ALT_PARENT_3 (numeric).}
 \item{ALT_PARENT_4 (numeric).}
 \item{ALT_PARENT_COMBN_1 (logical).}
 \item{ALT_PARENT_COMBN_2 (logical).}
 \item{ALT_PARENT_COMBN_3 (integer).}
 \item{ALT_PARENT_COMBN_4 (integer).}
 \item{ALT_FAM_COMBN_1 (integer).}
 \item{ALT_FAM_COMBN_2 (integer).}
 \item{ALT_FAM_COMBN_3 (integer).}
 \item{ALT_FAM_COMBN_4 (integer).}
}
\cr

\code{most.like.parents.excl}  
\cr  \cr
Applicable when method = "Exclusion".  Identifies the most likely parental 
combination.  Refer to Hamilton 2020.  Second most likely (alternative) parental 
combination is also presented.  
Example fields for n.in.pools = 2:
\itemize{
 \item{SAMPLE_ID (integer).}
 \item{PARENT_COMBN_ID (integer).}
 \item{MISMATCHES (integer).}
 \item{SNP_COUNT (integer).}
 \item{MISMATCH_PROP (numeric).}
 \item{MISMATCH_PROP_SE (numeric).}
 \item{MISMATCH_PROP_Z (numeric).}
 \item{FAM_COMBN_ID (integer).}
 \item{FAMILY_ID_1 (integer).}
 \item{FAMILY_ID_2 (integer).}
 \item{PARENT_1 (integer).}
 \item{PARENT_2 (integer).}
 \item{PARENT_3 (integer).}
 \item{PARENT_4 (integer).}
 \item{ALT_PARENT_COMBN_ID (integer).}
 \item{ALT_FAM_COMBN_ID (integer).}
 \item{ALT_MISMATCHES (integer).}
 \item{ALT_SNP_COUNT (integer).}
 \item{ALT_MISMATCH_PROP (numeric).}
 \item{ALT_MISMATCH_PROP_SE (numeric).}
 \item{ALT_MISMATCH_PROP_Z (numeric).}
}
\cr

\code{most.like.parents.excl.non.dup}
\cr \cr
 Applicable when method = "Exclusion".  Identifies the most likely parental
 combination - simplified output with multiple combinations with the same number of mismatches (duplicated 
 SAMPLE_IDs) removed.  Refer to Hamilton 2020.  Example fields for n.in.pools = 2:
\itemize{
 \item{SAMPLE_ID (integer).}
 \item{MISMATCHES (integer).}
 \item{SNP_COUNT (integer).}
 \item{MISMATCH_PROP (numeric).}
 \item{MISMATCH_PROP_SE (numeric).}
 \item{MISMATCH_PROP_Z (numeric).}
 \item{FAMILY_ID_1 (integer).}
 \item{FAMILY_ID_2 (integer).}
 \item{PARENT_1 (integer).}
 \item{PARENT_2 (integer).}
 \item{PARENT_3 (integer).}
 \item{PARENT_4 (integer).}
}
\cr

\code{beta}
\cr \cr
Applicable when method = "Least_squares". Identifies the most likely parental combination:
\itemize{
 \item{SAMPLE_ID (integer).}
 \item{SIRE_ID (integer).}
 \item{DAM_ID (integer).}
 \item{FAMILY_ID (integer).}
 \item{BETA_STAR Refer to Henshall et al. 2014  (numeric).}
 \item{BETA_HAT Refer to Henshall et al. 2014 (numeric).}
 \item{BETA_HAT_CONSTRAINED  Constrained to have equal contributions from each FAMILY_SET_ID. Refer to Hamilton 2020}
 \item{BETA_MIN_SS Applicable when beta.min.ss = "TRUE". Constrained beta with minimum sum of squares is retained.  Beta constrained to have equal contributions from each FAMILY_SET_ID.  Refer to Hamilton 2020}
}
\cr
\strong{Primary plots}

\code{bar.png} 
\itemize{
 \item{Bar plot of BETA_HAT by FAMILY_ID.  Applicable to 'Least_squares' method only.  Output in a directory named 'Results' on the current working directory.} 
}

\code{discrete.png} 
\itemize{
 \item{Scatter plot of '5-95 percentile range of log-likelihood ratios' against 'Log odds (LOD) scores' for each 
 possible family combination.  Ideally there is an isolated point in the bottom right represtenting the 
 correct family combination.  Applicable to 'Discrete' method only.  Output in a directory named 
 'Results/lod.scatter' on the current working directory.} 
}

\code{quantitative.png} 
\itemize{
 \item{Scatter plot of '5-95 percentile range of log-likelihood ratios' against 'Log odds (LOD) scores' for each 
 possible family combination.  Ideally there is an isolated point in the bottom right represtenting the 
 correct family combination.  Applicable to 'Quantitative' method only.  Output in a directory named 
 'Results/lod.scatter' on the current working directory.} 
}
\cr
\strong{Intermediate outputs}
\cr

'Dij' Applicable when method = "Discrete" or "Exclusion". Refer to Henshall et al. 2014
#:

'dkj' Applicable when method = "Discrete" or "Exclusion". Refer to Hamilton 2020
#:

'dklj.adj' Applicable when method = "Discrete" or "Exclusion". Refer to Hamilton 2020 (dkj.star)
#:

'fkj.and.weight' Applicable when method = "Least_squares". Refer to Henshall et al. 2014
#:

'Gij' Applicable when method = "Discrete" or ""Quantitative". Refer to Henshall et al. 2014
#:

'gkj' Applicable when method = "Discrete" or ""Quantitative". Refer to Hamilton 2020 
#:

'gklj.adj' Applicable when method = "Discrete" or ""Quantitative". Refer to Hamilton 2020 (gkj.star)
#:

'flj.probs' Applicable when discrete.method = "geno.probs". Refer to Hamilton 2020 (fj)
#:

'flj.geno' Applicable when discrete.method = "assigned.genos". Refer to Hamilton 2020 (fj)
#:

'lambda.kj' Applicable when method = "Discrete" or ""Quantitative". Refer to Hamilton 2020. 
#Example output for n.in.pools = 2#:

'lod.duos.discrete' Applicable when method = "Discrete". Refer to Hamilton 2020.
#:

'lod.duos.quant' Applicable when method = "Quantitative". Refer to Hamilton 2020.
#:

'logl.duos.discrete' Applicable when method = "Discrete". Refer to Hamilton 2020. Only outputted for the final SAMPLE_ID
#:

'logl.duos.quant' Applicable when method = "Quantitative". Refer to Hamilton 2020. Only outputted for the final SAMPLE_ID
#:

'mismatches' Applicable when method = "Exclusion". Refer to Hamilton 2020.
#:

'mismatches.by.snp' Applicable when method = "Exclusion". Refer to Hamilton 2020. 
#Example output for n.in.pools = 2:

'nlj.probs' Applicable when discrete.method = "geno.probs". Refer to Hamilton 2020 (nj). 
#Example output for n.in.pools = 2:

'nlj.geno'  Applicable when discrete.method = "geno.probs". Refer to Hamilton 2020 (nj).
# Example output for n.in.pools = 2:

'parent.combns':

'phi.ij' Applicable when method = "Discrete" or ""Quantitative". Refer to Henshall et al. 2014
#:

'snp.error.probs' Applicable when discrete.method = "geno.probs". Refer to Henshall et al. 2014
#:

'snp.error.geno'  Applicable when discrete.method = "assigned.genos". Refer to Henshall et al. 2014
#:

'tclj.adj.quant' Applicable when method = "Quantitative". Refer to Hamilton 2020 (tcj.star). 
#Example output for n.in.pools = 2:

'tclj.adj.discrete' Applicable when method = "Discrete". Refer to Hamilton 2020 (tcj.star). 
#Example output for n.in.pools = 2:

'tclj.discrete' Applicable when method = "Discrete". Refer to Hamilton 2020 (tcj). 
#Example output for n.in.pools = 2:

'tclj.ls' Applicable when method = "Least_squares". Refer to Hamilton 2020 (tcj).
3:

'tclj.quant' Applicable when method = "Quantitative". Refer to Hamilton 2020 (tcj). 
#Example output for n.in.pools = 2::

'Xl.mat' List Applicable when method = "Quantitative". Refer to Henshall et al 2014 (X)
#:
}
\description{
This function assigns parents to pooled samples using one of seven approaches:
\itemize{
 \item{'Least squares' method outlined in Henshall et al. 2014 (method = "Least_squares")} 
 \item{'Least squares minimum sum of squares' method whereby the sum of squares of all parental combinations are computed and 
  the combination with the minimum value identified.  Refer to Hamilton 2020 (method = "Least_squares", beta.min.ss = TRUE)} 
 \item{'Quantitative maximum likelihood' method whereby the approach using quantititive genotypes for parentatge assignment
 outlined in Henshall et al. 2014 is extended to pooled DNA samples.  Refer to Hamilton 2020 (method = "Quantitative")}
 \item{'Discrete maximum likelihood from genotype probabilities' method whereby discrete genotypes are derived from genotype probabilities and  
 used for parentatge assignment of pooled DNA samples by extending the discrete genotype maximum likelihood approach outlined in 
 Henshall et al. 2014 to pooled DNA samples.  Refer to Hamilton 2020 (method = "Discrete", discrete.method = "geno.probs").}
 \item{'Discrete maximum likelihood from genotype assignments' method whereby discrete genotypes are provided as input and  
 used for parentatge assignment of pooled DNA samples by extending the discrete genotype maximum likelihood approach outlined in 
 Henshall et al. 2014 to pooled DNA samples.  Refer to Hamilton 2020 (method = "Discrete", discrete.method = "assigned.genos")}
 \item{'Exclusion from genotype probabilities' method whereby discrete genotypes are derived from genotype probabilities and  
 used for parentatge assignment of pooled DNA samples by extending the exclusion approach outlined in 
 Henshall et al. 2014 to pooled DNA samples  Refer to Hamilton 2020 (method = "Exclusion", discrete.method = "geno.probs").}
 \item{'Exclusion from genotype assignments' method whereby discrete genotypes are provided as input and  
 used for parentatge assignment of pooled DNA samples by extending the exclusion approach outlined in 
 Henshall et al. 2014 to pooled DNA samples.  Refer to Hamilton 2020 (method = "Exclusion", discrete.method = "assigned.genos")}
}
}
\examples{

#' #Retrieve data for 'pooling by phenotype' example from Hamilton 2020
data(shrimp.snp.dat.indiv)
data(shrimp.snp.dat.pools)
data(shrimp.fams)

#Compute SNP parameters
shrimp.snp.param.indiv <- snp.param.indiv.fun(shrimp.snp.dat.indiv)
shrimp.snp.param.pools <- snp.param.pools.fun(shrimp.snp.param.indiv, n.in.pools = 2)

#Assign parentage using the quantitative maximum likelihood method
parent.assign.fun(method= "Quantitative",
                  snp.dat.indiv = shrimp.snp.dat.indiv, 
                  snp.dat.pools = shrimp.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = shrimp.snp.param.indiv,
                  snp.param.pools = shrimp.snp.param.pools,                  
                  fams = shrimp.fams)  

#Retrieve data for 'pooling for individual parentage assignment' example from Hamilton 2020
data(ab.snp.dat.indiv)
data(ab.snp.dat.pools)
data(ab.fams)
data(ab.fam.set.combns)
data(ab.fam.set.combns.by.pool)

#Compute SNP parameters
ab.snp.param.indiv <- snp.param.indiv.fun(ab.snp.dat.indiv)
ab.snp.param.pools <- snp.param.pools.fun(ab.snp.param.indiv, n.in.pools = 3)

#Assign parentage using the quantitative maximum likelihood method
parent.assign.fun(method= "Quantitative",
                  snp.dat.indiv = ab.snp.dat.indiv, 
                  snp.dat.pools = ab.snp.dat.pools,
                  n.in.pools = 3,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = ab.snp.param.indiv,
                  snp.param.pools = ab.snp.param.pools,                  
                  fams = ab.fams,
                  fam.set.combns = ab.fam.set.combns,
                  fam.set.combns.by.pool = ab.fam.set.combns.by.pool) 
                  
#Retrieve data for small worked example from Hamilton 2020
data(Ham.snp.dat.indiv)
data(Ham.snp.dat.pools)
data(Ham.fams)
data(Ham.fam.set.combns)
data(Ham.fam.set.combns.by.pool)

#Compute SNP parameters
Ham.snp.param.indiv <- snp.param.indiv.fun(Ham.snp.dat.indiv)
Ham.snp.param.pools <- snp.param.pools.fun(Ham.snp.param.indiv, n.in.pools = 2)

#Assign parentage using the least squares method
parent.assign.fun(method = "Least_squares",
                  beta.min.ss = TRUE, 
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = Ham.snp.param.indiv,
                  snp.param.pools = Ham.snp.param.pools,                  
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)
                  
#Assign parentage using the quantitative maximum likelihood method
parent.assign.fun(method= "Quantitative",
                  threshold.indiv = 0.98,         
                  threshold.pools = 0.98,         
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = Ham.snp.param.indiv,
                  snp.param.pools = Ham.snp.param.pools,                  
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)  
                  
#Assign parentage using the discrete maximum likelihood method 
#(discrete.method = "geno.probs")
parent.assign.fun(method= "Discrete",
                  discrete.method = "geno.probs",
                  threshold.indiv = 0.98,         
                  threshold.pools = 0.98,         
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = Ham.snp.param.indiv,
                  snp.param.pools = Ham.snp.param.pools,                  
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)  
                  
#Assign parentage using the discrete maximum likelihood method 
#(discrete.method = "assigned.genos")
parent.assign.fun(method= "Discrete",
                  discrete.method = "assigned.genos",
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)    
  
#Assign parentage using the exclusion method 
#(discrete.method = "geno.probs")
parent.assign.fun(method= "Exclusion",
                  discrete.method = "geno.probs",
                  threshold.indiv = 0.98,         
                  threshold.pools = 0.98,         
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = Ham.snp.param.indiv,
                  snp.param.pools = Ham.snp.param.pools,                  
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)   
                                  
#Assign parentage using the exclusion method 
#(discrete.method = "assigned.genos")
parent.assign.fun(method= "Exclusion",
                  discrete.method = "assigned.genos",
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)   
 
#Assign parentage using multiple methods
#(discrete.method = "geno.probs")
parent.assign.fun(method = c("Least_squares", "Quantitative", "Discrete", "Exclusion"),
                  beta.min.ss = TRUE, 
                  discrete.method = "geno.probs",
                  threshold.indiv = 0.98,         
                  threshold.pools = 0.98,         
                  snp.dat.indiv = Ham.snp.dat.indiv, 
                  snp.dat.pools = Ham.snp.dat.pools,
                  n.in.pools = 2,
                  snp.error.assumed = 0.01,
                  snp.param.indiv = Ham.snp.param.indiv,
                  snp.param.pools = Ham.snp.param.pools,                  
                  fams = Ham.fams,
                  fam.set.combns = Ham.fam.set.combns,
                  fam.set.combns.by.pool = Ham.fam.set.combns.by.pool)  
                  
}
\references{
Henshall JM, Dierens, L Sellars MJ (2014) Quantitative analysis of low-density SNP data for parentage assignment and estimation of family contributions to pooled samples. Genetics Selection Evolution 46, 51. https://doi 10.1186/s12711-014-0051-y

Hamilton MG (2020) Maximum likelihood parentage assignment using quantitative genotypes
}
